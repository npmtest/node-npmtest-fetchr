{"/home/travis/build/npmtest/node-npmtest-fetchr/test.js":"/* istanbul instrument in package npmtest_fetchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fetchr/lib.npmtest_fetchr.js":"/* istanbul instrument in package npmtest_fetchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fetchr = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fetchr = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fetchr/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fetchr && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fetchr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fetchr\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fetchr.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fetchr.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fetchr.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fetchr.__dirname + '/lib.npmtest_fetchr.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fetchr/node_modules/fetchr/index.js":"/**\n * Copyright 2014, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nmodule.exports = require('./libs/fetcher');\n","/home/travis/build/npmtest/node-npmtest-fetchr/node_modules/fetchr/libs/fetcher.js":"/**\n * Copyright 2014, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar OP_READ = 'read';\nvar OP_CREATE = 'create';\nvar OP_UPDATE = 'update';\nvar OP_DELETE = 'delete';\nvar GET = 'GET';\nvar qs = require('querystring');\nvar debug = require('debug')('Fetchr');\nvar fumble = require('fumble');\nvar objectAssign = require('object-assign');\nvar Promise = global.Promise || require('es6-promise').Promise;\nvar RESOURCE_SANTIZER_REGEXP = /[^\\w\\.]+/g;\n\nfunction parseValue(value) {\n    // take care of value of type: array, object\n    try {\n        var ret = JSON.parse(value);\n        // Big interger, big decimal and the number in exponential notations will results\n        // in unexpected form. e.g. 1234e1234 will be parsed into Infinity and the\n        // number > MAX_SAFE_INTEGER will cause a rounding error.\n        // So we will just leave them as strings instead.\n        if (typeof ret === 'number' && String(value) !== String(ret)) {\n            ret = value;\n        }\n        return ret;\n    } catch (e) {\n        return value;\n    }\n}\n\nfunction parseParamValues (params) {\n    return Object.keys(params).reduce(function (parsed, curr) {\n        parsed[curr] = parseValue(params[curr]);\n        return parsed;\n    }, {});\n}\n\nfunction sanitizeResourceName(resource) {\n    return resource ? resource.replace(RESOURCE_SANTIZER_REGEXP, '*') : resource;\n}\n\n/**\n * Takes an error and resolves output and statusCode to respond to client with\n *\n * @param  {Error} JavaScript error\n * @return {Object} object with resolved statusCode & output\n */\nfunction getErrorResponse(err) {\n    var statusCode = err.statusCode || 500;\n    var output = {\n        message: 'request failed'\n    };\n\n    if (typeof err.output !== 'undefined') {\n        output = err.output;\n    } else if (err.message) {\n        output.message = err.message;\n    }\n\n    return {\n        statusCode: statusCode,\n        output: output\n    };\n}\n\n\n/**\n * A Request instance represents a single fetcher request.\n * The constructor requires `operation` (CRUD) and `resource`.\n * @class Request\n * @param {String} operation The CRUD operation name: 'create|read|update|delete'.\n * @param {String} resource name of service\n * @param {Object} options configuration options for Request\n * @param {Object} [options.req] The request object from express/connect.  It can contain per-request/context data.\n * @param {Array} [options.serviceMeta] Array to hold per-request/session metadata from all service calls.\n * @param {Function} [options.statsCollector] The function will be invoked with 1 argument:\n *      the stats object, which contains resource, operation, params (request params),\n *      statusCode, err, and time (elapsed time)\n * @constructor\n */\nfunction Request (operation, resource, options) {\n    if (!resource) {\n        throw new Error('Resource is required for a fetcher request');\n    }\n\n    this.operation = operation || OP_READ;\n    this.resource = resource;\n    options = options || {};\n    this.req = options.req || {};\n    this.serviceMeta = options.serviceMeta || [];\n    this._params = {};\n    this._body = null;\n    this._clientConfig = {};\n    this._startTime = 0;\n    this._statsCollector = options.statsCollector;\n}\n\n/**\n * Add params to this fetcher request\n * @method params\n * @memberof Request\n * @param {Object} params Information carried in query and matrix parameters in typical REST API\n * @chainable\n */\nRequest.prototype.params = function (params) {\n    this._params = params;\n    return this;\n};\n/**\n * Add body to this fetcher request\n * @method body\n * @memberof Request\n * @param {Object} body The JSON object that contains the resource data being updated for this request.\n *                      Not used for read and delete operations.\n * @chainable\n */\nRequest.prototype.body = function (body) {\n    this._body = body;\n    return this;\n};\n/**\n * Add clientConfig to this fetcher request\n * @method config\n * @memberof Request\n * @param {Object} config config for this fetcher request\n * @chainable\n */\nRequest.prototype.clientConfig = function (config) {\n    this._clientConfig = config;\n    return this;\n};\n\n/**\n * capture meta data; capture stats for this request and pass stats data\n * to options.statsCollector\n * @method _captureMetaAndStats\n * @param {Object} errData  The error response for failed request\n * @param {Object} result  The response data for successful request\n */\nRequest.prototype._captureMetaAndStats = function (errData, result) {\n    var self = this;\n    var meta = (errData && errData.meta) || (result && result.meta);\n    if (meta) {\n        self.serviceMeta.push(meta);\n    }\n    var statsCollector = self._statsCollector;\n    if (typeof statsCollector === 'function') {\n        var err = errData && errData.err;\n        var stats = {\n            resource: self.resource,\n            operation: self.operation,\n            params: self._params,\n            statusCode: err ? err.statusCode : (result && result.meta && result.meta.statusCode || 200),\n            err: err,\n            time: Date.now() - self._startTime\n        };\n        statsCollector(stats);\n    }\n};\n\n/**\n * Execute this fetcher request and call callback.\n * @method end\n * @memberof Request\n * @param {Fetcher~fetcherCallback} callback callback invoked when service is complete.\n */\nRequest.prototype.end = function (callback) {\n    var self = this;\n    self._startTime = Date.now();\n\n    var promise = new Promise(function requestExecutor(resolve, reject) {\n        setImmediate(executeRequest, self, resolve, reject);\n    });\n\n    promise = promise.then(function requestSucceeded(result) {\n        self._captureMetaAndStats(null, result);\n        return result;\n    }, function requestFailed(errData) {\n        self._captureMetaAndStats(errData);\n        throw errData.err;\n    });\n\n    if (callback) {\n        promise.then(function requestSucceeded(result) {\n            setImmediate(callback, null, result.data, result.meta);\n        }, function requestFailed(err) {\n            setImmediate(callback, err);\n        });\n    } else {\n        return promise;\n    }\n};\n\n/**\n * Execute and resolve/reject this fetcher request\n * @method executeRequest\n * @param {Object} request Request instance object\n * @param {Function} resolve function to call when request fulfilled\n * @param {Function} reject function to call when request rejected\n */\nfunction executeRequest (request, resolve, reject) {\n    var args = [request.req, request.resource, request._params, request._clientConfig, function executeRequestCallback(err, data, meta) {\n        if (err) {\n            reject({\n                err: err,\n                meta: meta\n            });\n        } else {\n            resolve({\n                data: data,\n                meta: meta\n            });\n        }\n    }];\n    var op = request.operation;\n    if ((op === OP_CREATE) || (op === OP_UPDATE)) {\n        args.splice(3, 0, request._body);\n    }\n    var service;\n    try {\n        service = Fetcher.getService(request.resource);\n        if (!service[op]) {\n          throw new Error('operation: ' + op + ' is undefined on service: ' + request.resource);\n        }\n        service[op].apply(service, args);\n    } catch (err) {\n        reject({err: err});\n    }\n}\n\n/**\n * Fetcher class for the server.\n * Provides interface to register data services and\n * to later access those services.\n * @class Fetcher\n * @param {Object} options configuration options for Fetcher\n * @param {Object} [options.req] The express request object.  It can contain per-request/context data.\n * @param {string} [options.xhrPath=\"/api\"] The path for XHR requests. Will be ignored server side.\n * @param {Function} [options.statsCollector] The function will be invoked with 1 argument:\n *      the stats object, which contains resource, operation, params (request params),\n *      statusCode, err, and time (elapsed time)\n * @constructor\n */\nfunction Fetcher (options) {\n    this.options = options || {};\n    this.req = this.options.req || {};\n    this._serviceMeta = [];\n}\n\nFetcher.services = {};\n\n/**\n * DEPRECATED\n * Register a data fetcher\n * @method registerFetcher\n * @memberof Fetcher\n * @param {Function} fetcher\n */\nFetcher.registerFetcher = function (fetcher) {\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('Fetcher.registerFetcher is deprecated. ' +\n    //         'Please use Fetcher.registerService instead.');\n    // }\n    return Fetcher.registerService(fetcher);\n};\n\n/**\n * Register a data service\n * @method registerService\n * @memberof Fetcher\n * @param {Function} service\n */\nFetcher.registerService = function (fetcher) {\n    if (!fetcher || !fetcher.name) {\n        throw new Error('Service is not defined correctly');\n    }\n    Fetcher.services[fetcher.name] = fetcher;\n    debug('fetcher ' + fetcher.name + ' added');\n    return;\n};\n\n/**\n * DEPRECATED\n * Retrieve a data fetcher by name\n * @method getFetcher\n * @memberof Fetcher\n * @param {String} name of fetcher\n * @returns {Function} fetcher\n */\nFetcher.getFetcher = function (name) {\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('Fetcher.getFetcher is deprecated. ' +\n    //         'Please use Fetcher.getService instead.');\n    // }\n    return Fetcher.getService(name);\n};\n\n/**\n * Retrieve a data service by name\n * @method getService\n * @memberof Fetcher\n * @param {String} name of service\n * @returns {Function} service\n */\nFetcher.getService = function (name) {\n    //Access service by name\n    var service = Fetcher.isRegistered(name);\n    if (!service) {\n        throw new Error('Service \"' + sanitizeResourceName(name) + '\" could not be found');\n    }\n    return service;\n};\n\n/**\n * Returns true if service with name has been registered\n * @method isRegistered\n * @memberof Fetcher\n * @param {String} name of service\n * @returns {Boolean} true if service with name was registered\n */\nFetcher.isRegistered = function (name) {\n    return name && Fetcher.services[name.split('.')[0]];\n};\n\n/**\n * Returns express/connect middleware for Fetcher\n * @method middleware\n * @memberof Fetcher\n * @param {Object} [options] Optional configurations\n * @param {Function} [options.responseFormatter=no op function] Function to modify the response\n            before sending to client. First argument is the HTTP request object,\n            second argument is the HTTP response object and the third argument is the service data object.\n * @param {Function} [options.statsCollector] The function will be invoked with 1 argument:\n           the stats object, which contains resource, operation, params (request params),\n           statusCode, err, and time (elapsed time)\n * @returns {Function} middleware\n *     @param {Object} req\n *     @param {Object} res\n *     @param {Object} next\n */\nFetcher.middleware = function (options) {\n    options = options || {};\n    var responseFormatter = options.responseFormatter || function noOp(req, res, data) {\n        return data;\n    };\n    return function (req, res, next) {\n        var request;\n        var error;\n        var serviceMeta;\n\n        if (req.method === GET) {\n            var path = req.path.substr(1).split(';');\n            var resource = path.shift();\n\n            if (!Fetcher.isRegistered(resource)) {\n                error = fumble.http.badRequest('Invalid Fetchr Access', {\n                    debug: 'Bad resource ' + sanitizeResourceName(resource)\n                });\n                error.source = 'fetchr';\n                return next(error);\n            }\n            serviceMeta = [];\n            request = new Request(OP_READ, resource, {\n                req: req,\n                serviceMeta: serviceMeta,\n                statsCollector: options.statsCollector\n            });\n            request\n                .params(parseParamValues(qs.parse(path.join('&'))))\n                .end(function (err, data) {\n                    var meta = serviceMeta[0] || {};\n                    if (meta.headers) {\n                        res.set(meta.headers);\n                    }\n                    if (err) {\n                        var errResponse = getErrorResponse(err);\n                        if (req.query && req.query.returnMeta) {\n                            res.status(errResponse.statusCode).json(responseFormatter(req, res, {\n                                output: errResponse.output,\n                                meta: meta\n                            }));\n                        } else {\n                            res.status(errResponse.statusCode).json(responseFormatter(req, res, errResponse.output));\n                        }\n                        return;\n                    }\n                    if (req.query.returnMeta) {\n                        res.status(meta.statusCode || 200).json(responseFormatter(req, res, {\n                            data: data,\n                            meta: meta\n                        }));\n                    } else {\n                        // TODO: Remove `returnMeta` feature flag after next release\n                        res.status(meta.statusCode || 200).json(data);\n                    }\n                });\n        } else {\n            var requests = req.body && req.body.requests;\n\n            if (!requests || Object.keys(requests).length === 0) {\n                error = fumble.http.badRequest('Invalid Fetchr Access', {\n                    debug: 'No resources'\n                });\n                error.source = 'fetchr';\n                return next(error);\n            }\n\n            var DEFAULT_GUID = 'g0';\n            var singleRequest = requests[DEFAULT_GUID];\n\n            if (!Fetcher.isRegistered(singleRequest.resource)) {\n                error = fumble.http.badRequest('Invalid Fetchr Access', {\n                    debug: 'Bad resource ' + sanitizeResourceName(singleRequest.resource)\n                });\n                error.source = 'fetchr';\n                return next(error);\n            }\n            var operation = singleRequest.operation;\n            if(operation !== OP_CREATE && operation !== OP_UPDATE && operation !== OP_DELETE && operation !== OP_READ) {\n                error = fumble.http.badRequest('Invalid Fetchr Access', {\n                    debug: 'Unsupported operation : operation must be create or read or update or delete'\n                });\n                error.source = 'fetchr';\n                return next(error);\n            }\n            serviceMeta = [];\n            request = new Request(operation, singleRequest.resource, {\n                req: req,\n                serviceMeta: serviceMeta,\n                statsCollector: options.statsCollector\n            });\n            request\n                .params(singleRequest.params)\n                .body(singleRequest.body || {})\n                .end(function(err, data) {\n                    var meta = serviceMeta[0] || {};\n                    if (meta.headers) {\n                        res.set(meta.headers);\n                    }\n                    if (err) {\n                        var errResponse = getErrorResponse(err);\n                        res.status(errResponse.statusCode).json(responseFormatter(req, res, errResponse.output));\n                        return;\n                    }\n                    var responseObj = {};\n                    responseObj[DEFAULT_GUID] = responseFormatter(req, res, {\n                        data: data,\n                        meta: meta\n                    });\n                    res.status(meta.statusCode || 200).json(responseObj);\n                });\n        }\n        // TODO: Batching and multi requests\n    };\n};\n\n\n// ------------------------------------------------------------------\n// CRUD Data Access Wrapper Methods\n// ------------------------------------------------------------------\n\n/**\n * read operation (read as in CRUD).\n * @method read\n * @memberof Fetcher.prototype\n * @param {String} resource  The resource name\n * @param {Object} params    The parameters identify the resource, and along with information\n *                           carried in query and matrix parameters in typical REST API\n * @param {Object} [config={}] The config object.  It can contain \"config\" for per-request config data.\n * @param {Fetcher~fetcherCallback} callback callback invoked when fetcher is complete.\n * @static\n */\nFetcher.prototype.read = function (resource, params, config, callback) {\n    var request = new Request('read', resource, {\n        req: this.req,\n        serviceMeta: this._serviceMeta,\n        statsCollector: this.options.statsCollector\n    });\n    if (1 === arguments.length) {\n        return request;\n    }\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('The recommended way to use fetcher\\'s .read method is \\n' +\n    //         '.read(\\'' + resource + '\\').params({foo:bar}).end(callback);');\n    // }\n    // TODO: Remove below this line in release after next\n    if (typeof config === 'function') {\n        callback = config;\n        config = {};\n    }\n    return request\n        .params(params)\n        .clientConfig(config)\n        .end(callback);\n};\n/**\n * create operation (create as in CRUD).\n * @method create\n * @memberof Fetcher.prototype\n * @param {String} resource  The resource name\n * @param {Object} params    The parameters identify the resource, and along with information\n *                           carried in query and matrix parameters in typical REST API\n * @param {Object} body      The JSON object that contains the resource data that is being created\n * @param {Object} [config={}] The config object.  It can contain \"config\" for per-request config data.\n * @param {Fetcher~fetcherCallback} callback callback invoked when fetcher is complete.\n * @static\n */\nFetcher.prototype.create = function (resource, params, body, config, callback) {\n    var request = new Request('create', resource, {\n        req: this.req,\n        serviceMeta: this._serviceMeta,\n        statsCollector: this.options.statsCollector\n    });\n    if (1 === arguments.length) {\n        return request;\n    }\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('The recommended way to use fetcher\\'s .create method is \\n' +\n    //         '.create(\\'' + resource + '\\').params({foo:bar}).body({}).end(callback);');\n    // }\n    // TODO: Remove below this line in release after next\n    if (typeof config === 'function') {\n        callback = config;\n        config = {};\n    }\n    return request\n        .params(params)\n        .body(body)\n        .clientConfig(config)\n        .end(callback);\n};\n/**\n * update operation (update as in CRUD).\n * @method update\n * @memberof Fetcher.prototype\n * @param {String} resource  The resource name\n * @param {Object} params    The parameters identify the resource, and along with information\n *                           carried in query and matrix parameters in typical REST API\n * @param {Object} body      The JSON object that contains the resource data that is being updated\n * @param {Object} [config={}] The config object.  It can contain \"config\" for per-request config data.\n * @param {Fetcher~fetcherCallback} callback callback invoked when fetcher is complete.\n * @static\n */\nFetcher.prototype.update = function (resource, params, body, config, callback) {\n    var request = new Request('update', resource, {\n        req: this.req,\n        serviceMeta: this._serviceMeta,\n        statsCollector: this.options.statsCollector\n    });\n    if (1 === arguments.length) {\n        return request;\n    }\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('The recommended way to use fetcher\\'s .update method is \\n' +\n    //         '.update(\\'' + resource + '\\').params({foo:bar}).body({}).end(callback);');\n    // }\n    // TODO: Remove below this line in release after next\n    if (typeof config === 'function') {\n        callback = config;\n        config = {};\n    }\n    return request\n        .params(params)\n        .body(body)\n        .clientConfig(config)\n        .end(callback);\n};\n/**\n * delete operation (delete as in CRUD).\n * @method delete\n * @memberof Fetcher.prototype\n * @param {String} resource  The resource name\n * @param {Object} params    The parameters identify the resource, and along with information\n *                           carried in query and matrix parameters in typical REST API\n * @param {Object} [config={}] The config object.  It can contain \"config\" for per-request config data.\n * @param {Fetcher~fetcherCallback} callback callback invoked when fetcher is complete.\n * @static\n */\nFetcher.prototype['delete'] = function (resource, params, config, callback) {\n    var request = new Request('delete', resource, {\n        req: this.req,\n        serviceMeta: this._serviceMeta,\n        statsCollector: this.options.statsCollector\n    });\n    if (1 === arguments.length) {\n        return request;\n    }\n\n    // TODO: Uncomment warnings in next minor release\n    // if ('production' !== process.env.NODE_ENV) {\n    //     console.warn('The recommended way to use fetcher\\'s .read method is \\n' +\n    //         '.read(\\'' + resource + '\\').params({foo:bar}).end(callback);');\n    // }\n    // TODO: Remove below this line in release after next\n    if (typeof config === 'function') {\n        callback = config;\n        config = {};\n    }\n    return request\n        .params(params)\n        .clientConfig(config)\n        .end(callback);\n};\n\n/**\n * update fetchr options\n * @method updateOptions\n * @memberof Fetcher.prototype\n * @param {Object} options configuration options for Fetcher\n * @param {Object} [options.req] The request object.  It can contain per-request/context data.\n * @param {string} [options.xhrPath=\"/api\"] The path for XHR requests. Will be ignored server side.\n */\nFetcher.prototype.updateOptions = function (options) {\n    this.options = objectAssign(this.options, options);\n    this.req = this.options.req || {};\n};\n\n/**\n * Get all the aggregated metadata sent data services in this request\n */\nFetcher.prototype.getServiceMeta = function () {\n    return this._serviceMeta;\n};\n\nmodule.exports = Fetcher;\n\n/**\n * @callback Fetcher~fetcherCallback\n * @param {Object} err  The request error, pass null if there was no error. The data and meta parameters will be ignored if this parameter is not null.\n * @param {number} [err.statusCode=500] http status code to return\n * @param {string} [err.message=request failed] http response body\n * @param {Object} data request result\n * @param {Object} [meta] request meta-data\n * @param {number} [meta.statusCode=200] http status code to return\n */\n","/home/travis/build/npmtest/node-npmtest-fetchr/node_modules/fetchr/libs/fetcher.client.js":"/**\n * Copyright 2014, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/*jslint plusplus:true,nomen:true */\n\n/**\n * Fetcher is a CRUD interface for your data.\n * @module Fetcher\n */\nvar REST = require('./util/http.client');\nvar debug = require('debug')('FetchrClient');\nvar lodash = {\n        isFunction: require('lodash/isFunction'),\n        forEach: require('lodash/forEach'),\n        merge: require('lodash/merge'),\n        noop: require('lodash/noop'),\n        pickBy: require('lodash/pickBy'),\n        pick: require('lodash/pick')\n    };\nvar DEFAULT_GUID = 'g0';\nvar DEFAULT_XHR_PATH = '/api';\nvar DEFAULT_XHR_TIMEOUT = 3000;\nvar MAX_URI_LEN = 2048;\nvar OP_READ = 'read';\nvar defaultConstructGetUri = require('./util/defaultConstructGetUri');\nvar Promise = global.Promise || require('es6-promise').Promise;\n\nfunction parseResponse(response) {\n    if (response && response.responseText) {\n        try {\n            return JSON.parse(response.responseText);\n        } catch (e) {\n            debug('json parse failed:' + e, 'error');\n            return null;\n        }\n    }\n    return null;\n}\n\n/**\n * Pick keys from the context object\n * @method pickContext\n * @param {Object} context context object\n * @param {Function|Array|String} picker picker object w/iteratee for lodash/pickBy|pick\n * @param {String} method method name, get or post\n */\nfunction pickContext (context, picker, method) {\n    if (picker && picker[method]) {\n        var libPicker = lodash.isFunction(picker[method]) ? lodash.pickBy : lodash.pick;\n        return libPicker(context, picker[method]);\n    }\n    return context;\n}\n\n/**\n * A RequestClient instance represents a single fetcher request.\n * The constructor requires `operation` (CRUD) and `resource`.\n * @class RequestClient\n * @param {String} operation The CRUD operation name: 'create|read|update|delete'.\n * @param {String} resource name of fetcher/service\n * @param {Object} options configuration options for Request\n * @param {Array} [options._serviceMeta] Array to hold per-request/session metadata from all service calls.\n * Data will be pushed on to this array while the Fetchr instance maintains the reference for this session.\n *\n * @constructor\n */\nfunction Request (operation, resource, options) {\n    if (!resource) {\n        throw new Error('Resource is required for a fetcher request');\n    }\n\n    this.operation = operation || OP_READ;\n    this.resource = resource;\n    this.options = {\n        headers: options.headers,\n        xhrPath: options.xhrPath || DEFAULT_XHR_PATH,\n        xhrTimeout: options.xhrTimeout || DEFAULT_XHR_TIMEOUT,\n        corsPath: options.corsPath,\n        context: options.context || {},\n        contextPicker: options.contextPicker || {},\n        statsCollector: options.statsCollector,\n        _serviceMeta: options._serviceMeta || []\n    };\n    this._params = {};\n    this._body = null;\n    this._clientConfig = {};\n    this._startTime = 0;\n}\n\n/**\n * Add params to this fetcher request\n * @method params\n * @memberof Request\n * @param {Object} params Information carried in query and matrix parameters in typical REST API\n * @chainable\n */\nRequest.prototype.params = function (params) {\n    this._params = params || {};\n    return this;\n};\n\n/**\n * Add body to this fetcher request\n * @method body\n * @memberof Request\n * @param {Object} body The JSON object that contains the resource data being updated for this request.\n *                      Not used for read and delete operations.\n * @chainable\n */\nRequest.prototype.body = function (body) {\n    this._body = body || null;\n    return this;\n};\n\n/**\n * Add clientConfig to this fetcher request\n * @method clientConfig\n * @memberof Request\n * @param {Object} config config for this fetcher request\n * @chainable\n */\nRequest.prototype.clientConfig = function (config) {\n    this._clientConfig = config || {};\n    return this;\n};\n\n/**\n * capture meta data; capture stats for this request and pass stats data\n * to options.statsCollector\n * @method _captureMetaAndStats\n * @param {Object} err  The error response for failed request\n * @param {Object} result  The response data for successful request\n */\nRequest.prototype._captureMetaAndStats = function (err, result) {\n    var self = this;\n    var meta = (err && err.meta) || (result && result.meta);\n    if (meta) {\n        self.options._serviceMeta.push(meta);\n    }\n    var statsCollector = self.options.statsCollector;\n    if (typeof statsCollector === 'function') {\n        var stats = {\n            resource: self.resource,\n            operation: self.operation,\n            params: self._params,\n            statusCode: err ? err.statusCode : 200,\n            err: err,\n            time: Date.now() - self._startTime\n        };\n        statsCollector(stats);\n    }\n};\n\n/**\n * Execute this fetcher request and call callback.\n * @method end\n * @memberof Request\n * @param {Fetcher~fetcherCallback} callback callback invoked when fetcher/service is complete.\n * @async\n */\nRequest.prototype.end = function (callback) {\n    var self = this;\n    self._startTime = Date.now();\n\n    if (callback) {\n        return executeRequest(self, function requestSucceeded(result) {\n            self._captureMetaAndStats(null, result);\n            setImmediate(callback, null, result && result.data, result && result.meta);\n        }, function requestFailed(err) {\n            self._captureMetaAndStats(err);\n            setImmediate(callback, err);\n        });\n    } else {\n        var promise = new Promise(function requestExecutor(resolve, reject) {\n            debug('Executing request %s.%s with params %o and body %o', self.resource, self.operation, self._params, self._body);\n            setImmediate(executeRequest, self, resolve, reject);\n        });\n        promise = promise.then(function requestSucceeded(result) {\n            self._captureMetaAndStats(null, result);\n            return result;\n        }, function requestFailed(err) {\n            self._captureMetaAndStats(err);\n            throw err;\n        });\n        return promise;\n    }\n};\n\n/**\n * Execute and resolve/reject this fetcher request\n * @method executeRequest\n * @param {Object} request Request instance object\n * @param {Function} resolve function to call when request fulfilled\n * @param {Function} reject function to call when request rejected\n */\nfunction executeRequest (request, resolve, reject) {\n    var clientConfig = request._clientConfig;\n    var use_post;\n    var allow_retry_post;\n    var uri = clientConfig.uri;\n    var requests;\n    var params;\n    var data;\n\n    if (!uri) {\n        uri = clientConfig.cors ? request.options.corsPath : request.options.xhrPath;\n    }\n\n    use_post = request.operation !== OP_READ || clientConfig.post_for_read;\n    // We use GET request by default for READ operation, but you can override that behavior\n    // by specifying {post_for_read: true} in your request's clientConfig\n    if (!use_post) {\n        var getUriFn = lodash.isFunction(clientConfig.constructGetUri) ? clientConfig.constructGetUri : defaultConstructGetUri;\n        var get_uri = getUriFn.call(request, uri, request.resource, request._params, clientConfig, pickContext(request.options.context, request.options.contextPicker, 'GET'));\n        /* istanbul ignore next */\n        if (!get_uri) {\n            // If a custom getUriFn returns falsy value, we should run defaultConstructGetUri\n            // TODO: Add test for this fallback\n            get_uri = defaultConstructGetUri.call(request, uri, request.resource, request._params, clientConfig, request.options.context);\n        }\n        // TODO: Remove `returnMeta` feature flag after next release\n        // This feature flag will enable the new return format for GET api requests\n        // Whereas before any data from services was returned as is. We now return\n        // an object with a data key containing the service response, and a meta key\n        // containing the service's metadata response (i.e headers and statusCode).\n        // We need this feature flag to be truly backwards compatible because it is\n        // concievable that some active browser sessions could have the old version of\n        // client fetcher while the server upgrades to the new version. This could be\n        // easily fixed by refreshing the browser, but the feature flag will ensure\n        // old fetcher clients will receive the old format and the new client will\n        // receive the new format\n        get_uri += (get_uri.indexOf('?') !== -1) ? '&' : '?';\n        get_uri += 'returnMeta=true';\n        if (get_uri.length <= MAX_URI_LEN) {\n            uri = get_uri;\n        } else {\n            use_post = true;\n        }\n    }\n\n    var customHeaders = clientConfig.headers || request.options.headers || {};\n    if (!use_post) {\n        return REST.get(uri, customHeaders, lodash.merge({xhrTimeout: request.options.xhrTimeout}, clientConfig), function getDone(err, response) {\n            if (err) {\n                debug('Syncing ' + request.resource + ' failed: statusCode=' + err.statusCode, 'info');\n                return reject(err);\n            }\n            resolve(parseResponse(response));\n        });\n    }\n\n    // individual request is also normalized into a request hash to pass to api\n    requests = {};\n    requests[DEFAULT_GUID] = {\n        resource: request.resource,\n        operation: request.operation,\n        params: request._params\n    };\n    if (request._body) {\n        requests[DEFAULT_GUID].body = request._body;\n    }\n    data = {\n        requests: requests,\n        context: request.options.context\n    }; // TODO: remove. leave here for now for backward compatibility\n    uri = request._constructGroupUri(uri);\n    allow_retry_post = (request.operation === OP_READ);\n    return REST.post(uri, customHeaders, data, lodash.merge({unsafeAllowRetry: allow_retry_post, xhrTimeout: request.options.xhrTimeout}, clientConfig), function postDone(err, response) {\n        if (err) {\n            debug('Syncing ' + request.resource + ' failed: statusCode=' + err.statusCode, 'info');\n            return reject(err);\n        }\n        var result = parseResponse(response);\n        if (result) {\n            result = result[DEFAULT_GUID] || {};\n        } else {\n            result = {};\n        }\n        resolve(result);\n    });\n}\n\n/**\n * Build a final uri by adding query params to base uri from this.context\n * @method _constructGroupUri\n * @param {String} uri the base uri\n * @private\n */\nRequest.prototype._constructGroupUri = function (uri) {\n    var query = [];\n    var final_uri = uri;\n    lodash.forEach(pickContext(this.options.context, this.options.contextPicker, 'POST'), function eachContext(v, k) {\n        query.push(k + '=' + encodeURIComponent(v));\n    });\n    if (query.length > 0) {\n        final_uri += '?' + query.sort().join('&');\n    }\n    return final_uri;\n};\n\n/**\n * Fetcher class for the client. Provides CRUD methods.\n * @class FetcherClient\n * @param {Object} options configuration options for Fetcher\n * @param {String} [options.xhrPath=\"/api\"] The path for XHR requests\n * @param {Number} [options.xhrTimout=3000] Timeout in milliseconds for all XHR requests\n * @param {Boolean} [options.corsPath] Base CORS path in case CORS is enabled\n * @param {Object} [options.context] The context object that is propagated to all outgoing\n *      requests as query params.  It can contain current-session/context data that should\n *      persist to all requests.\n * @param {Object} [options.contextPicker] The context picker for GET and POST, they must be\n *      lodash pick predicate function with three arguments (value, key, object)\n * @param {Function|String|String[]} [options.contextPicker.GET] GET context picker\n * @param {Function|String|String[]} [options.contextPicker.POST] POST context picker\n * @param {Function} [options.statsCollector] The function will be invoked with 1 argument:\n *      the stats object, which contains resource, operation, params (request params),\n *      statusCode, err, and time (elapsed time)\n */\n\nfunction Fetcher (options) {\n    this._serviceMeta = [];\n    this.options = {\n        headers: options.headers,\n        xhrPath: options.xhrPath,\n        xhrTimeout: options.xhrTimeout,\n        corsPath: options.corsPath,\n        context: options.context,\n        contextPicker: options.contextPicker,\n        statsCollector: options.statsCollector,\n        _serviceMeta: this._serviceMeta\n    };\n}\n\nFetcher.prototype = {\n    // ------------------------------------------------------------------\n    // Data Access Wrapper Methods\n    // ------------------------------------------------------------------\n\n    /**\n     * create operation (create as in CRUD).\n     * @method create\n     * @param {String} resource     The resource name\n     * @param {Object} params       The parameters identify the resource, and along with information\n     *                              carried in query and matrix parameters in typical REST API\n     * @param {Object} body         The JSON object that contains the resource data that is being created\n     * @param {Object} clientConfig The \"config\" object for per-request config data.\n     * @param {Function} callback   callback convention is the same as Node.js\n     * @static\n     */\n    create: function (resource, params, body, clientConfig, callback) {\n        var request = new Request('create', resource, this.options);\n        if (1 === arguments.length) {\n            return request;\n        }\n        // TODO: Remove below this line in release after next\n        if (typeof clientConfig === 'function') {\n            callback = clientConfig;\n            clientConfig = {};\n        }\n        return request\n            .params(params)\n            .body(body)\n            .clientConfig(clientConfig)\n            .end(callback);\n    },\n\n    /**\n     * read operation (read as in CRUD).\n     * @method read\n     * @param {String} resource     The resource name\n     * @param {Object} params       The parameters identify the resource, and along with information\n     *                              carried in query and matrix parameters in typical REST API\n     * @param {Object} clientConfig The \"config\" object for per-request config data.\n     * @param {Function} callback   callback convention is the same as Node.js\n     * @static\n     */\n    read: function (resource, params, clientConfig, callback) {\n        var request = new Request('read', resource, this.options);\n        if (1 === arguments.length) {\n            return request;\n        }\n        // TODO: Remove below this line in release after next\n        if (typeof clientConfig === 'function') {\n            callback = clientConfig;\n            clientConfig = {};\n        }\n        return request\n            .params(params)\n            .clientConfig(clientConfig)\n            .end(callback);\n    },\n\n    /**\n     * update operation (update as in CRUD).\n     * @method update\n     * @param {String} resource     The resource name\n     * @param {Object} params       The parameters identify the resource, and along with information\n     *                              carried in query and matrix parameters in typical REST API\n     * @param {Object} body         The JSON object that contains the resource data that is being updated\n     * @param {Object} clientConfig The \"config\" object for per-request config data.\n     * @param {Function} callback   callback convention is the same as Node.js\n     * @static\n     */\n    update: function (resource, params, body, clientConfig, callback) {\n        var request = new Request('update', resource, this.options);\n        if (1 === arguments.length) {\n            return request;\n        }\n        // TODO: Remove below this line in release after next\n        if (typeof clientConfig === 'function') {\n            callback = clientConfig;\n            clientConfig = {};\n        }\n        return request\n            .params(params)\n            .body(body)\n            .clientConfig(clientConfig)\n            .end(callback);\n    },\n\n    /**\n     * delete operation (delete as in CRUD).\n     * @method delete\n     * @param {String} resource     The resource name\n     * @param {Object} params       The parameters identify the resource, and along with information\n     *                              carried in query and matrix parameters in typical REST API\n     * @param {Object} clientConfig The \"config\" object for per-request config data.\n     * @param {Function} callback   callback convention is the same as Node.js\n     * @static\n     */\n    'delete': function (resource, params, clientConfig, callback) {\n        var request = new Request('delete', resource, this.options);\n        if (1 === arguments.length) {\n            return request;\n        }\n        // TODO: Remove below this line in release after next\n        if (typeof clientConfig === 'function') {\n            callback = clientConfig;\n            clientConfig = {};\n        }\n        return request\n            .params(params)\n            .clientConfig(clientConfig)\n            .end(callback);\n    },\n\n    /**\n     * Update options\n     * @method updateOptions\n     */\n    updateOptions: function (options) {\n        this.options = lodash.merge(this.options, options);\n    },\n\n    /**\n     * get the serviceMeta array.\n     * The array contains all xhr meta returned in this session\n     * with the 0 index being the first call.\n     * @method getServiceMeta\n     * @return {Array} array of metadata returned by each service call\n     */\n    getServiceMeta: function () {\n        return this._serviceMeta;\n    }\n};\n\nmodule.exports = Fetcher;\n","/home/travis/build/npmtest/node-npmtest-fetchr/node_modules/fetchr/libs/util/http.client.js":"/**\n * Copyright 2014, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n/*jslint nomen:true,plusplus:true*/\n/**\n * @module rest-http\n */\n\n/*\n * Default configurations:\n *   timeout: timeout (in ms) for each request\n *   retry: retry related settings, such as retry interval amount (in ms), max_retries.\n *          Note that only retry only applies on GET.\n */\nvar _ = {\n        forEach: require('lodash/forEach'),\n        some: require('lodash/some'),\n        delay: require('lodash/delay'),\n        isNumber: require('lodash/isNumber')\n    },\n    DEFAULT_CONFIG = {\n        retry: {\n            interval: 200,\n            max_retries: 0\n        }\n    },\n    CONTENT_TYPE = 'Content-Type',\n    TYPE_JSON = 'application/json',\n    METHOD_GET = 'GET',\n    METHOD_PUT = 'PUT',\n    METHOD_POST = 'POST',\n    METHOD_DELETE = 'DELETE',\n    NULL = null,\n    xhr = require('xhr');\n\n//trim polyfill, maybe pull from npm later\nif (!String.prototype.trim) {\n  String.prototype.trim = function () {\n    return this.replace(/^\\s+|\\s+$/g, '');\n  };\n}\n\nfunction normalizeHeaders(headers, method, isCors) {\n    var normalized = {};\n    if (!isCors) {\n        normalized['X-Requested-With'] = 'XMLHttpRequest';\n    }\n    var needContentType = (method === METHOD_PUT || method === METHOD_POST);\n    _.forEach(headers, function (v, field) {\n        if (field.toLowerCase() === 'content-type') {\n            if (needContentType) {\n                normalized[CONTENT_TYPE] = v;\n            }\n        } else {\n            normalized[field] = v;\n        }\n    });\n\n    if (needContentType && !normalized[CONTENT_TYPE]) {\n        normalized[CONTENT_TYPE] = TYPE_JSON;\n    }\n\n    return normalized;\n}\n\nfunction isContentTypeJSON(headers) {\n    if (!headers[CONTENT_TYPE]) {\n        return false;\n    }\n\n    return _.some(headers[CONTENT_TYPE].split(';'), function (part) {\n        return part.trim().toLowerCase() === TYPE_JSON;\n    });\n}\n\nfunction shouldRetry(method, config, statusCode) {\n    var isIdempotent = (method === METHOD_GET || method === METHOD_PUT || method === METHOD_DELETE);\n    if (!isIdempotent && !config.unsafeAllowRetry) {\n        return false;\n    }\n    if ((statusCode !== 0 && statusCode !== 408 && statusCode !== 999) || config.tmp.retry_counter >= config.retry.max_retries) {\n        return false;\n    }\n    config.tmp.retry_counter++;\n    config.retry.interval =  config.retry.interval * 2;\n    return true;\n}\n\nfunction mergeConfig(config) {\n    var cfg = {\n            unsafeAllowRetry: config.unsafeAllowRetry || false,\n            retry: {\n                interval: DEFAULT_CONFIG.retry.interval,\n                max_retries: DEFAULT_CONFIG.retry.max_retries\n            }\n        }, // Performant-but-verbose way of cloning the default config as base\n        timeout,\n        interval,\n        maxRetries;\n\n    if (config) {\n        timeout = config.timeout || config.xhrTimeout;\n        timeout = parseInt(timeout, 10);\n        if (_.isNumber(timeout) && timeout > 0) {\n            cfg.timeout = timeout;\n        }\n\n        if (config.retry) {\n            interval = parseInt(config.retry && config.retry.interval, 10);\n            if (_.isNumber(interval) && interval > 0) {\n                cfg.retry.interval = interval;\n            }\n            maxRetries = parseInt(config.retry && config.retry.max_retries, 10);\n            if (_.isNumber(maxRetries) && maxRetries >= 0) {\n                cfg.retry.max_retries = maxRetries;\n            }\n        }\n\n        if (config.withCredentials) {\n            cfg.withCredentials = config.withCredentials;\n        }\n\n        // tmp stores transient state data, such as retry count\n        if (config.tmp) {\n            cfg.tmp = config.tmp;\n        }\n    }\n\n    return cfg;\n}\n\nfunction doXhr(method, url, headers, data, config, callback) {\n    var options, timeout;\n\n    headers = normalizeHeaders(headers, method, config.cors);\n    config = mergeConfig(config);\n    // use config.tmp to store temporary values\n    config.tmp = config.tmp || {retry_counter: 0};\n\n    timeout = config.timeout;\n    options = {\n        method : method,\n        timeout : timeout,\n        headers: headers,\n        useXDR: config.useXDR,\n        withCredentials: config.withCredentials,\n        on : {\n            success : function (err, response) {\n                callback(NULL, response);\n            },\n            failure : function (err, response) {\n                if (!shouldRetry(method, config, response.statusCode)) {\n                    callback(err);\n                } else {\n                    _.delay(\n                        function retryXHR() { doXhr(method, url, headers, data, config, callback); },\n                        config.retry.interval\n                    );\n                }\n            }\n        }\n    };\n    if (data !== undefined && data !== NULL) {\n        options.data = isContentTypeJSON(headers) ? JSON.stringify(data) : data;\n    }\n    return io(url, options);\n}\n\nfunction io(url, options) {\n    return xhr({\n        url: url,\n        method: options.method || METHOD_GET,\n        timeout: options.timeout,\n        headers: options.headers,\n        body: options.data,\n        useXDR: options.cors,\n        withCredentials: options.withCredentials\n    }, function (err, resp, body) {\n        var status = resp.statusCode;\n        var errMessage, errBody;\n\n        if (!err && (status === 0 || (status >= 400 && status < 600))) {\n            if (typeof body === 'string') {\n                try {\n                    errBody = JSON.parse(body);\n                    if (errBody.message) {\n                        errMessage = errBody.message;\n                    } else {\n                        errMessage = body;\n                    }\n                } catch(e) {\n                    errMessage = body;\n                }\n            } else {\n                errMessage = status ? 'Error ' + status : 'Internal Fetchr XMLHttpRequest Error';\n            }\n\n            err = new Error(errMessage);\n            err.statusCode = status;\n            err.body = errBody || body;\n            if (err.body) {\n                err.output = err.body.output;\n                err.meta = err.body.meta;\n            }\n        }\n\n        resp.responseText = body;\n\n        if (err) {\n            // getting detail info from xhr module\n            err.rawRequest = resp.rawRequest;\n            err.url = resp.url;\n            err.timeout = options.timeout;\n\n            options.on.failure.call(null, err, resp);\n        } else {\n            options.on.success.call(null, null, resp);\n        }\n    });\n}\n\n/**\n * @class REST.HTTP\n */\nmodule.exports = {\n    /**\n     * @method get\n     * @public\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Object} config  The config object.\n     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request\n     * @param {Object} config.retry   Retry config object.\n     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).\n     * @param {Number} [config.retry.max_retries=2]   Number of max retries.\n     * @param {Boolean} [config.cors] Whether to enable CORS & use XDR on IE8/9.\n     * @param {Function} callback The callback function, with two params (error, response)\n     */\n    get : function (url, headers, config, callback) {\n        return doXhr(METHOD_GET, url, headers, NULL, config, callback);\n    },\n\n    /**\n     * @method put\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Mixed}  data\n     * @param {Object} config  The config object. No retries for PUT.\n     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request\n     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).\n     * @param {Number} [config.retry.max_retries=2]   Number of max retries.\n     * @param {Boolean} [config.cors] Whether to enable CORS & use XDR on IE8/9.\n     * @param {Function} callback The callback function, with two params (error, response)\n     */\n    put : function (url, headers, data, config, callback) {\n        return doXhr(METHOD_PUT, url, headers, data, config, callback);\n    },\n\n    /**\n     * @method post\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Mixed}  data\n     * @param {Object} config  The config object. No retries for POST.\n     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request\n     * @param {Boolean} [config.unsafeAllowRetry=false] Whether to allow retrying this post.\n     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).\n     * @param {Number} [config.retry.max_retries=2]   Number of max retries.\n     * @param {Boolean} [config.cors] Whether to enable CORS & use XDR on IE8/9.\n     * @param {Function} callback The callback function, with two params (error, response)\n     */\n    post : function (url, headers, data, config, callback) {\n        return doXhr(METHOD_POST, url, headers, data, config, callback);\n    },\n\n    /**\n     * @method delete\n     * @param {String} url\n     * @param {Object} headers\n     * @param {Object} config  The config object. No retries for DELETE.\n     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request\n     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).\n     * @param {Number} [config.retry.max_retries=2]   Number of max retries.\n     * @param {Boolean} [config.cors] Whether to enable CORS & use XDR on IE8/9.\n     * @param {Function} callback The callback function, with two params (error, response)\n     */\n    'delete' : function (url, headers, config, callback) {\n        return doXhr(METHOD_DELETE, url, headers, NULL, config, callback);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-fetchr/node_modules/fetchr/libs/util/defaultConstructGetUri.js":"/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar debug = require('debug')('Fetcher:defaultConstructGetUri');\nvar lodash = {\n    forEach: require('lodash/forEach'),\n    isArray: require('lodash/isArray'),\n    isObject: require('lodash/isObject')\n};\n\nfunction jsonifyComplexType(value) {\n    if (lodash.isArray(value) || lodash.isObject(value)) {\n        return JSON.stringify(value);\n    }\n    return value;\n}\n\n/**\n * Construct xhr GET URI.\n * @method defaultConstructGetUri\n * @param {String} uri base URI\n * @param {String} resource Resource name\n * @param {Object} params Parameters to be serialized\n * @param {Object} config Configuration object\n * @param {String} config.id_param  Name of the id parameter\n * @param {Object} context Context object, which will become query params\n */\nmodule.exports = function defaultConstructGetUri(baseUri, resource, params, config, context) {\n    var query = [];\n    var matrix = [];\n    var id_param = config.id_param;\n    var id_val;\n    var final_uri = baseUri + '/' + resource;\n\n    if (params) {\n        lodash.forEach(params, function eachParam(v, k) {\n            if (k === id_param) {\n                id_val = encodeURIComponent(v);\n            } else if (v !== undefined) {\n                try {\n                    matrix.push(k + '=' + encodeURIComponent(jsonifyComplexType(v)));\n                } catch (err) {\n                    debug('jsonifyComplexType failed: ' + err);\n                }\n            }\n        });\n    }\n\n    if (context) {\n        lodash.forEach(context, function eachContext(v, k) {\n            query.push(k + '=' + encodeURIComponent(jsonifyComplexType(v)));\n        });\n    }\n\n    if (id_val) {\n        final_uri += '/' + id_param + '/' + id_val;\n    }\n    if (matrix.length > 0) {\n        final_uri += ';' + matrix.sort().join(';');\n    }\n    if (query.length > 0) {\n        final_uri += '?' + query.sort().join('&');\n    }\n    debug('constructed get uri:', final_uri);\n    return final_uri;\n};\n"}